* 6809 assembly program generated by cmoc 0.1.85


	SECTION	code


_isCoCo3	IMPORT
_textScreenWidth	IMPORT
_textScreenHeight	IMPORT
_palette	EXPORT
_FS_STANDARD	EXPORT
___va_arg	IMPORT
_abs	IMPORT
_adddww	IMPORT
_atanf	IMPORT
_atoff	IMPORT
_atoi	IMPORT
_atol	IMPORT
_atoui	IMPORT
_atoul	IMPORT
_attr	IMPORT
_bsearch	IMPORT
_cls	IMPORT
_cmp	IMPORT
_cmpdww	IMPORT
_coldStart	IMPORT
_cosf	IMPORT
_delay	IMPORT
_divdwb	IMPORT
_divdww	IMPORT
_divmod16	IMPORT
_divmod8	IMPORT
_dwtoa	IMPORT
_enableCMOCFloatSupport	IMPORT
_exit	IMPORT
_expf	IMPORT
_fabsf	IMPORT
_floorf	IMPORT
_ftoa	IMPORT
_getTextMode	IMPORT
_hscreen	IMPORT
_hset	IMPORT
_initCoCoSupport	IMPORT
_inkey	IMPORT
_isKeyPressed	IMPORT
_isalnum	IMPORT
_isalpha	IMPORT
_isdigit	IMPORT
_isspace	IMPORT
_itoa10	IMPORT
_labs	IMPORT
_locate	IMPORT
_logf	IMPORT
_ltoa10	IMPORT
_memchr	IMPORT
_memcmp	IMPORT
_memcpy	IMPORT
_memichr	IMPORT
_memicmp	IMPORT
_memmove	IMPORT
_memset	IMPORT
_memset16	IMPORT
_mulwb	IMPORT
_mulww	IMPORT
_palette	IMPORT
_paletteRGB	IMPORT
_pcls	IMPORT
_pmode	IMPORT
_printf	IMPORT
_putchar	IMPORT
_putstr	IMPORT
_qsort	IMPORT
_rand	IMPORT
_ray	IMPORT
_readDECBFile	IMPORT
_readJoystickButtons	IMPORT
_readJoystickPositions	IMPORT
_readline	IMPORT
_readword	IMPORT
_resetPalette	IMPORT
_rgb	IMPORT
_roundf	IMPORT
_sbrk	IMPORT
_sbrkmax	IMPORT
_screen	IMPORT
_setBorderColor	IMPORT
_setCaseFlag	IMPORT
_setConsoleOutHook	IMPORT
_setHighSpeed	IMPORT
_setOutputDevice	IMPORT
_setPmodeGraphicsAddressEx	IMPORT
_setSAMRegisters	IMPORT
_set_null_ptr_handler	IMPORT
_set_stack_overflow_handler	IMPORT
_showGraphicsAddress	IMPORT
_showLowResTextAddress	IMPORT
_showPmode4	IMPORT
_sinf	IMPORT
_sleep	IMPORT
_sound	IMPORT
_sprintf	IMPORT
_sqrt16	IMPORT
_sqrt32	IMPORT
_sqrtf	IMPORT
_srand	IMPORT
_strcat	IMPORT
_strchr	IMPORT
_strcmp	IMPORT
_strcpy	IMPORT
_stricmp	IMPORT
_strlen	IMPORT
_strlwr	IMPORT
_strncmp	IMPORT
_strncpy	IMPORT
_strstr	IMPORT
_strtof	IMPORT
_strtol	IMPORT
_strtoul	IMPORT
_strupr	IMPORT
_subdww	IMPORT
_tanf	IMPORT
_tolower	IMPORT
_toupper	IMPORT
_truncf	IMPORT
_ultoa10	IMPORT
_utoa10	IMPORT
_vec_diff	IMPORT
_vec_dot	IMPORT
_vec_len	IMPORT
_vec_scale	IMPORT
_vec_sum	IMPORT
_vprintf	IMPORT
_vsprintf	IMPORT
_waitkey	IMPORT
_width	IMPORT
_zerodw	IMPORT
_findNearestColor	EXPORT


*******************************************************************************

* FUNCTION findNearestColor(): defined at errdiff.c:39
_findNearestColor	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-68,S
* Formal parameter(s):
*      4,U:   15 bytes: c: struct color_type
*     20,U:    1 byte : multiply: char
* Local non-static variable(s):
*    -68,U:    5 bytes: $V00133: float
*    -63,U:    5 bytes: $V00134: float
*    -58,U:    5 bytes: $V00135: float
*    -53,U:    5 bytes: $V00136: float
*    -48,U:    5 bytes: $V00137: float
*    -43,U:    5 bytes: $V00138: float
*    -38,U:    5 bytes: $V00139: float
*    -33,U:    5 bytes: $V00140: float
*    -28,U:    5 bytes: $V00141: float
*    -23,U:    5 bytes: $V00142: float
*    -18,U:    5 bytes: $V00143: float
*    -13,U:    1 byte : i: unsigned char
*    -12,U:    2 bytes: minIndex: int
*    -10,U:    5 bytes: minDistance: float
*     -5,U:    5 bytes: distance: float
* Line errdiff.c:41: init of variable minIndex
	CLRA
	CLRB
	STD	-12,U		variable minIndex
* Line errdiff.c:42: init of variable minDistance
	LEAX	F00155,PCR	real constant: 400000 (float)
	TFR	X,D		address of source number in D
	LEAX	-10,U		address of variable to init: minDistance
	LBSR	initSingleFromSingle
* Line errdiff.c:43: init of variable distance
	CLRA
	CLRB
	LEAX	-5,U		address of variable distance
	LBSR	initSingleFromSignedWord
* Line errdiff.c:45: if
	LDB	20,U		variable `multiply', declared at errdiff.c:39
* optim: loadCmpZeroBeqOrBne
	BEQ	L00157		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00156 removed
* Line errdiff.c:45
* Line errdiff.c:46: assignment: *=
* Push right operand of mul.
	LEAX	F00158,PCR	real constant: 255 (float)
	PSHS	X
* Push left operand of mul.
	LEAX	4,U		member r of color_type, via variable c
	PSHS	X
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
* Line errdiff.c:47: assignment: *=
* Push right operand of mul.
	LEAX	F00158,PCR	real constant: 255 (float)
	PSHS	X
* Push left operand of mul.
	LEAX	9,U		member g of color_type, via variable c
	PSHS	X
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
* Line errdiff.c:48: assignment: *=
* Push right operand of mul.
	LEAX	F00158,PCR	real constant: 255 (float)
	PSHS	X
* Push left operand of mul.
	LEAX	14,U		member b of color_type, via variable c
	PSHS	X
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
L00157	EQU	*		else clause of if() started at errdiff.c:45
* Useless label L00159 removed
* Line errdiff.c:51: for init
* Line errdiff.c:51: init of variable i
	CLR	-13,U		variable i
	LBRA	L00161		jump to for condition
L00160	EQU	*
* Line errdiff.c:51: for body
* Line errdiff.c:56: assignment: =
* Push right operand of add.
* Push right operand of mul.
* Push right operand of sub.
	LDB	-13,U		variable i
* optim: stripOpToDeadReg
	LDA	#15		size of array element
	MUL			get offset in bytes in D
	LEAX	_palette+0,PCR	address of array palette
	LEAX	D,X		add offset
	LEAX	10,X		member b of color_type
	PSHS	X
* Push left operand of sub.
	LEAX	14,U		member b of color_type, via variable c
	PSHS	X
	LEAX	-18,U		temporary destination, type float
	LBSR	subSingleSingle	preserves X
	LEAS	4,S
	PSHS	X
* Push left operand of mul.
* Push right operand of sub.
	LDB	-13,U		variable i
* optim: stripOpToDeadReg
	LDA	#15		size of array element
	MUL			get offset in bytes in D
	LEAX	_palette+0,PCR	address of array palette
	LEAX	D,X		add offset
	LEAX	10,X		member b of color_type
	PSHS	X
* Push left operand of sub.
	LEAX	14,U		member b of color_type, via variable c
	PSHS	X
	LEAX	-23,U		temporary destination, type float
	LBSR	subSingleSingle	preserves X
	LEAS	4,S
	PSHS	X
	LEAX	-28,U		temporary destination, type float
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
	PSHS	X
* Push left operand of add.
* Push right operand of add.
* Push right operand of mul.
* Push right operand of sub.
	LDB	-13,U		variable i
* optim: stripOpToDeadReg
	LDA	#15		size of array element
	MUL			get offset in bytes in D
	LEAX	_palette+0,PCR	address of array palette
	LEAX	D,X		add offset
	LEAX	5,X		member g of color_type
	PSHS	X
* Push left operand of sub.
	LEAX	9,U		member g of color_type, via variable c
	PSHS	X
	LEAX	-33,U		temporary destination, type float
	LBSR	subSingleSingle	preserves X
	LEAS	4,S
	PSHS	X
* Push left operand of mul.
* Push right operand of sub.
	LDB	-13,U		variable i
* optim: stripOpToDeadReg
	LDA	#15		size of array element
	MUL			get offset in bytes in D
	LEAX	_palette+0,PCR	address of array palette
	LEAX	D,X		add offset
	LEAX	5,X		member g of color_type
	PSHS	X
* Push left operand of sub.
	LEAX	9,U		member g of color_type, via variable c
	PSHS	X
	LEAX	-38,U		temporary destination, type float
	LBSR	subSingleSingle	preserves X
	LEAS	4,S
	PSHS	X
	LEAX	-43,U		temporary destination, type float
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
	PSHS	X
* Push left operand of add.
* Push right operand of mul.
* Push right operand of sub.
	LDB	-13,U		variable i
* optim: stripOpToDeadReg
	LDA	#15		size of array element
	MUL			get offset in bytes in D
	LEAX	_palette+0,PCR	address of array palette
	LEAX	D,X		add offset
	PSHS	X
* Push left operand of sub.
	LEAX	4,U		member r of color_type, via variable c
	PSHS	X
	LEAX	-48,U		temporary destination, type float
	LBSR	subSingleSingle	preserves X
	LEAS	4,S
	PSHS	X
* Push left operand of mul.
* Push right operand of sub.
	LDB	-13,U		variable i
* optim: stripOpToDeadReg
	LDA	#15		size of array element
	MUL			get offset in bytes in D
	LEAX	_palette+0,PCR	address of array palette
	LEAX	D,X		add offset
	PSHS	X
* Push left operand of sub.
	LEAX	4,U		member r of color_type, via variable c
	PSHS	X
	LEAX	-53,U		temporary destination, type float
	LBSR	subSingleSingle	preserves X
	LEAS	4,S
	PSHS	X
	LEAX	-58,U		temporary destination, type float
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
	PSHS	X
	LEAX	-63,U		temporary destination, type float
	LBSR	addSingleSingle	preserves X
	LEAS	4,S
	PSHS	X
	LEAX	-68,U		temporary destination, type float
	LBSR	addSingleSingle	preserves X
	LEAS	4,S
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-5,U		variable `distance', declared at errdiff.c:43
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:61: if
* push right operand of comparison
	LEAX	-10,U		variable `minDistance', declared at errdiff.c:42
	PSHS	X
* push left operand of comparison
	LEAX	-5,U		variable `distance', declared at errdiff.c:43
	PSHS	X
	LBSR	cmpSingleSingle	sets N, Z, V, C; preserves X
	LEAS	4,S
	BGE	L00165		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00164 removed
* Line errdiff.c:61
* Line errdiff.c:62: assignment: =
	LDB	-13,U		variable `i', declared at errdiff.c:51
	CLRA
	LDB	-13,U
* optim: stripExtraClrA_B
	STD	-12,U
* Line errdiff.c:63: assignment: =
	LEAX	-5,U		variable `distance', declared at errdiff.c:43
	LDB	#5		optim: removeAndOrMulAddSub
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-10,U		variable `minDistance', declared at errdiff.c:42
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
L00165	EQU	*		else clause of if() started at errdiff.c:61
* Useless label L00166 removed
* Useless label L00162 removed
* Line errdiff.c:51: for increment(s)
	INC	-13,U
L00161	EQU	*
* Line errdiff.c:51: for condition
	LDB	-13,U		variable i
	CMPB	#$10
	LBLO	L00160
* optim: branchToNextLocation
* Useless label L00163 removed
* Line errdiff.c:66: return with value
	LDD	-12,U		variable `minIndex', declared at errdiff.c:41
* optim: branchToNextLocation
* Useless label L00128 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION findNearestColor(): defined at errdiff.c:39
funcend_findNearestColor	EQU *
funcsize_findNearestColor	EQU	funcend_findNearestColor-_findNearestColor
_multcol	EXPORT


*******************************************************************************

* FUNCTION multcol(): defined at errdiff.c:69
_multcol	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      6,U:   15 bytes: c: struct color_type
* Line errdiff.c:71: assignment: *=
* Push right operand of mul.
	LEAX	F00158,PCR	real constant: 255 (float)
	PSHS	X
* Push left operand of mul.
	LEAX	6,U		member r of color_type, via variable c
	PSHS	X
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
* Line errdiff.c:72: assignment: *=
* Push right operand of mul.
	LEAX	F00158,PCR	real constant: 255 (float)
	PSHS	X
* Push left operand of mul.
	LEAX	11,U		member g of color_type, via variable c
	PSHS	X
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
* Line errdiff.c:73: assignment: *=
* Push right operand of mul.
	LEAX	F00158,PCR	real constant: 255 (float)
	PSHS	X
* Push left operand of mul.
	LEAX	16,U		member b of color_type, via variable c
	PSHS	X
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
* Line errdiff.c:74: return struct/union by value
	LEAX	6,U		variable `c', declared at errdiff.c:69
	PSHS	X		source struct/union
	LDX	4,U		address of return value
	LDD	#15		size of struct color_type
	LBSR	copyMem
	LEAS	2,S		discard copyMem argument
* optim: branchToNextLocation
* Useless label L00129 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION multcol(): defined at errdiff.c:69
funcend_multcol	EQU *
funcsize_multcol	EQU	funcend_multcol-_multcol
_clip	EXPORT


*******************************************************************************

* FUNCTION clip(): defined at errdiff.c:77
_clip	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
* Formal parameter(s):
*      6,U:   15 bytes: c: struct color_type
* Line errdiff.c:79: if
* push right operand of comparison
	CLRA
	LDB	#$FF		decimal 255 signed
	PSHS	B,A
* push left operand of comparison
	LEAX	6,U		member r of color_type, via variable c
	PSHS	X
	LBSR	cmpSingleSignedInt	sets N, Z, V, C; preserves X
	LEAS	4,S
	BLE	L00168		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00167 removed
* Line errdiff.c:79
* Line errdiff.c:79: assignment: =
	CLRA
	LDB	#$FF		decimal 255 signed
* optim: stripUselessPushPull
	LEAX	6,U		member r of color_type, via variable c
* optim: stripUselessPushPull
	LBSR	initSingleFromSignedWord
L00168	EQU	*		else clause of if() started at errdiff.c:79
* Useless label L00169 removed
* Line errdiff.c:80: if
* push right operand of comparison
	CLRA
	LDB	#$FF		decimal 255 signed
	PSHS	B,A
* push left operand of comparison
	LEAX	11,U		member g of color_type, via variable c
	PSHS	X
	LBSR	cmpSingleSignedInt	sets N, Z, V, C; preserves X
	LEAS	4,S
	BLE	L00171		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00170 removed
* Line errdiff.c:80
* Line errdiff.c:80: assignment: =
	CLRA
	LDB	#$FF		decimal 255 signed
* optim: stripUselessPushPull
	LEAX	11,U		member g of color_type, via variable c
* optim: stripUselessPushPull
	LBSR	initSingleFromSignedWord
L00171	EQU	*		else clause of if() started at errdiff.c:80
* Useless label L00172 removed
* Line errdiff.c:81: if
* push right operand of comparison
	CLRA
	LDB	#$FF		decimal 255 signed
	PSHS	B,A
* push left operand of comparison
	LEAX	16,U		member b of color_type, via variable c
	PSHS	X
	LBSR	cmpSingleSignedInt	sets N, Z, V, C; preserves X
	LEAS	4,S
	BLE	L00174		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00173 removed
* Line errdiff.c:81
* Line errdiff.c:81: assignment: =
	CLRA
	LDB	#$FF		decimal 255 signed
* optim: stripUselessPushPull
	LEAX	16,U		member b of color_type, via variable c
* optim: stripUselessPushPull
	LBSR	initSingleFromSignedWord
L00174	EQU	*		else clause of if() started at errdiff.c:81
* Useless label L00175 removed
* Line errdiff.c:82: if
* push right operand of comparison
	CLRA
	CLRB
	PSHS	B,A
* push left operand of comparison
	LEAX	6,U		member r of color_type, via variable c
	PSHS	X
	LBSR	cmpSingleSignedInt	sets N, Z, V, C; preserves X
	LEAS	4,S
	BGE	L00177		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00176 removed
* Line errdiff.c:82
* Line errdiff.c:82: assignment: =
	CLRA
	CLRB
* optim: stripUselessPushPull
	LEAX	6,U		member r of color_type, via variable c
* optim: stripUselessPushPull
	LBSR	initSingleFromSignedWord
L00177	EQU	*		else clause of if() started at errdiff.c:82
* Useless label L00178 removed
* Line errdiff.c:83: if
* push right operand of comparison
	CLRA
	CLRB
	PSHS	B,A
* push left operand of comparison
	LEAX	11,U		member g of color_type, via variable c
	PSHS	X
	LBSR	cmpSingleSignedInt	sets N, Z, V, C; preserves X
	LEAS	4,S
	BGE	L00180		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00179 removed
* Line errdiff.c:83
* Line errdiff.c:83: assignment: =
	CLRA
	CLRB
* optim: stripUselessPushPull
	LEAX	11,U		member g of color_type, via variable c
* optim: stripUselessPushPull
	LBSR	initSingleFromSignedWord
L00180	EQU	*		else clause of if() started at errdiff.c:83
* Useless label L00181 removed
* Line errdiff.c:84: if
* push right operand of comparison
	CLRA
	CLRB
	PSHS	B,A
* push left operand of comparison
	LEAX	16,U		member b of color_type, via variable c
	PSHS	X
	LBSR	cmpSingleSignedInt	sets N, Z, V, C; preserves X
	LEAS	4,S
	BGE	L00183		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00182 removed
* Line errdiff.c:84
* Line errdiff.c:84: assignment: =
	CLRA
	CLRB
* optim: stripUselessPushPull
	LEAX	16,U		member b of color_type, via variable c
* optim: stripUselessPushPull
	LBSR	initSingleFromSignedWord
L00183	EQU	*		else clause of if() started at errdiff.c:84
* Useless label L00184 removed
* Line errdiff.c:85: return struct/union by value
	LEAX	6,U		variable `c', declared at errdiff.c:77
	PSHS	X		source struct/union
	LDX	4,U		address of return value
	LDD	#15		size of struct color_type
	LBSR	copyMem
	LEAS	2,S		discard copyMem argument
* optim: branchToNextLocation
* Useless label L00130 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION clip(): defined at errdiff.c:77
funcend_clip	EQU *
funcsize_clip	EQU	funcend_clip-_clip
_applyError	EXPORT


*******************************************************************************

* FUNCTION applyError(): defined at errdiff.c:88
_applyError	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-45,S
* Formal parameter(s):
*      6,U:   15 bytes: co: struct color_type
*     21,U:    2 bytes: qe: int *
*     23,U:    5 bytes: f: float
* Local non-static variable(s):
*    -45,U:    5 bytes: $V00144: float
*    -40,U:    5 bytes: $V00145: float
*    -35,U:    5 bytes: $V00146: float
*    -30,U:    5 bytes: $V00147: float
*    -25,U:    5 bytes: $V00148: float
*    -20,U:    5 bytes: $V00149: float
*    -15,U:   15 bytes: $V00150: struct color_type
* Line errdiff.c:90: assignment: =
* Push right operand of add.
* Push right operand of mul.
	LEAX	23,U		variable `f', declared at errdiff.c:88
	PSHS	X
* Push left operand of mul.
* optim: optimizeIndexedX
	LDD	[21,U]		optim: optimizeIndexedX
	PSHS	B,A
	LEAX	-40,U		temporary destination, type float
	LBSR	mulIntSingle	preserves X
	LEAS	4,S
	PSHS	X
* Push left operand of add.
	LEAX	6,U		member r of color_type, via variable co
	PSHS	X
	LEAX	-45,U		temporary destination, type float
	LBSR	addSingleSingle	preserves X
	LEAS	4,S
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	6,U		member r of color_type, via variable co
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:91: assignment: =
* Push right operand of add.
* Push right operand of mul.
	LEAX	23,U		variable `f', declared at errdiff.c:88
	PSHS	X
* Push left operand of mul.
	LDX	21,U		get pointer value
* optim: optimizeLeaxLdd
	LDD	2,X		optim: optimizeLeaxLdd
	PSHS	B,A
	LEAX	-30,U		temporary destination, type float
	LBSR	mulIntSingle	preserves X
	LEAS	4,S
	PSHS	X
* Push left operand of add.
	LEAX	11,U		member g of color_type, via variable co
	PSHS	X
	LEAX	-35,U		temporary destination, type float
	LBSR	addSingleSingle	preserves X
	LEAS	4,S
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	11,U		member g of color_type, via variable co
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:92: assignment: =
* Push right operand of add.
* Push right operand of mul.
	LEAX	23,U		variable `f', declared at errdiff.c:88
	PSHS	X
* Push left operand of mul.
	LDX	21,U		get pointer value
* optim: optimizeLeaxLdd
	LDD	4,X		optim: optimizeLeaxLdd
	PSHS	B,A
	LEAX	-20,U		temporary destination, type float
	LBSR	mulIntSingle	preserves X
	LEAS	4,S
	PSHS	X
* Push left operand of add.
	LEAX	16,U		member b of color_type, via variable co
	PSHS	X
	LEAX	-25,U		temporary destination, type float
	LBSR	addSingleSingle	preserves X
	LEAS	4,S
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	16,U		member b of color_type, via variable co
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:93: assignment: =
* Line errdiff.c:93: function call: clip()
	LEAX	6,U		variable `co', declared at errdiff.c:88
	LDB	#15		size of struct color_type
	LEAS	-15,S		pass struct color_type by value
	LBSR	pushSmallStruct	argument 1 of clip(): struct color_type
	LEAX	-15,U		address of struct/union to be returned by clip()
	PSHS	X		hidden argument
	LBSR	_clip
	LEAS	17,S
	LEAX	-15,U		address of struct/union returned by clip()
	LDD	#15		size of struct color_type
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	6,U		variable `co', declared at errdiff.c:88
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:94: return struct/union by value
	LEAX	6,U		variable `co', declared at errdiff.c:88
	PSHS	X		source struct/union
	LDX	4,U		address of return value
	LDD	#15		size of struct color_type
	LBSR	copyMem
	LEAS	2,S		discard copyMem argument
* optim: branchToNextLocation
* Useless label L00131 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION applyError(): defined at errdiff.c:88
funcend_applyError	EQU *
funcsize_applyError	EQU	funcend_applyError-_applyError
_errorDiffusiongDither	EXPORT


*******************************************************************************

* FUNCTION errorDiffusiongDither(): defined at errdiff.c:97
_errorDiffusiongDither	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-85,S
* Formal parameter(s):
*      4,U:    2 bytes: gd: struct GraphicsDriver *
*      6,U:    2 bytes: x: unsigned int
*      9,U:    1 byte : y: unsigned char
*     10,U:    2 bytes: co: struct color_type *
* Local non-static variable(s):
*    -85,U:   15 bytes: $V00154: struct color_type
*    -70,U:   15 bytes: $V00153: struct color_type
*    -55,U:    2 bytes: i: int
*    -53,U:    6 bytes: quantError: int[]
*    -47,U:   15 bytes: currentColor: struct color_type
*    -32,U:   15 bytes: closestMatch: struct color_type
*    -17,U:   15 bytes: screenPixel: struct color_type
*     -2,U:    2 bytes: cidx: int
* Line errdiff.c:103: for init
* Line errdiff.c:103: init of variable i
	CLRA
	CLRB
	STD	-55,U		variable i
	LBRA	L00186		jump to for condition
L00185	EQU	*
* Line errdiff.c:103: for body
* Line errdiff.c:104: assignment: =
	LDX	-55,U		variable i
	LDB	#15		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	LDD	#15		size of struct color_type
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-47,U		variable `currentColor', declared at errdiff.c:101
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:106: assignment: =
* Line errdiff.c:106: function call: findNearestColor()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of findNearestColor(): int
	LEAX	-47,U		variable `currentColor', declared at errdiff.c:101
	LDB	#15		size of struct color_type
	LEAS	-15,S		pass struct color_type by value
	LBSR	pushSmallStruct	argument 1 of findNearestColor(): struct color_type
	LBSR	_findNearestColor
	LEAS	17,S
	STD	-2,U
* Line errdiff.c:107: assignment: =
* optim: storeLoad
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LEAX	_palette+0,PCR	address of array palette
	LEAX	D,X		add offset
	LDD	#15		size of struct color_type
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-32,U		variable `closestMatch', declared at errdiff.c:101
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:109: assignment: =
	LEAX	-32,U		member r of color_type, via variable closestMatch
	TFR	X,D		cast to `int': address of source number in D
	LEAS	-2,S		result of cast
	LEAX	,S
	LBSR	initSignedWordFromSingle
	PULS	A,B		result of cast
	PSHS	B,A
	LEAX	-47,U		member r of color_type, via variable currentColor
	TFR	X,D		cast to `int': address of source number in D
	LEAS	-2,S		result of cast
	LEAX	,S
	LBSR	initSignedWordFromSingle
	PULS	A,B		result of cast
	SUBD	,S++
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	-53,U		optim: optimizeLeax
* Line errdiff.c:110: assignment: =
	LEAX	-27,U		member g of color_type, via variable closestMatch
	TFR	X,D		cast to `int': address of source number in D
	LEAS	-2,S		result of cast
	LEAX	,S
	LBSR	initSignedWordFromSingle
	PULS	A,B		result of cast
	PSHS	B,A
	LEAX	-42,U		member g of color_type, via variable currentColor
	TFR	X,D		cast to `int': address of source number in D
	LEAS	-2,S		result of cast
	LEAX	,S
	LBSR	initSignedWordFromSingle
	PULS	A,B		result of cast
	SUBD	,S++
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	-51,U		optim: optimizeLeax
* Line errdiff.c:111: assignment: =
	LEAX	-22,U		member b of color_type, via variable closestMatch
	TFR	X,D		cast to `int': address of source number in D
	LEAS	-2,S		result of cast
	LEAX	,S
	LBSR	initSignedWordFromSingle
	PULS	A,B		result of cast
	PSHS	B,A
	LEAX	-37,U		member b of color_type, via variable currentColor
	TFR	X,D		cast to `int': address of source number in D
	LEAS	-2,S		result of cast
	LEAX	,S
	LBSR	initSignedWordFromSingle
	PULS	A,B		result of cast
	SUBD	,S++
* optim: stripUselessPushPull
* optim: optimizeLeax
* optim: stripUselessPushPull
	STD	-49,U		optim: optimizeLeax
* Line errdiff.c:113: function call through pointer
	LDD	-2,U		variable `cidx', declared at errdiff.c:102
	PSHS	B,A		argument 3: int
	LDB	9,U		variable `y', declared at errdiff.c:97
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2: unsigned char
	LDD	-55,U		variable `i', declared at errdiff.c:103
	PSHS	B,A		argument 1: int
	LDX	4,U		variable gd
	LDX	6,X		optim: removeTfrDX
* optim: removeTfrDX
	JSR	,X
	LEAS	6,S
* Line errdiff.c:116: if
	LDD	-55,U		variable i
	ADDD	#$01		1
	CMPD	#320
	LBGE	L00190		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00189 removed
* Line errdiff.c:116
* Line errdiff.c:117: assignment: =
* Line errdiff.c:117: function call: applyError()
	LEAX	F00191,PCR	real constant: 0.4375 (float)
	LEAS	-5,S		pass float by value
	LBSR	push5ByteStruct	argument 3 of applyError(): float
	LEAX	-53,U		address of array quantError
	PSHS	X		argument 2 of applyError(): int[]
	LDD	-55,U		variable i
	ADDD	#$01		1
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	LDB	#15		size of struct color_type
	LEAS	-15,S		pass struct color_type by value
	LBSR	pushSmallStruct	argument 1 of applyError(): struct color_type
	LEAX	-85,U		address of struct/union to be returned by applyError()
	PSHS	X		hidden argument
	LBSR	_applyError
	LEAS	24,S
	LEAX	-85,U		address of struct/union returned by applyError()
	LDD	#15		size of struct color_type
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-17,U		variable `screenPixel', declared at errdiff.c:101
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:118: function call through pointer
* Line errdiff.c:118: function call: findNearestColor()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of findNearestColor(): int
	LEAX	-17,U		variable `screenPixel', declared at errdiff.c:101
	LDB	#15		size of struct color_type
	LEAS	-15,S		pass struct color_type by value
	LBSR	pushSmallStruct	argument 1 of findNearestColor(): struct color_type
	LBSR	_findNearestColor
	LEAS	17,S
	PSHS	B,A		argument 3: int
	LDB	9,U		variable `y', declared at errdiff.c:97
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2: unsigned char
	LDD	-55,U		variable i
	ADDD	#$01		1
	PSHS	B,A		argument 1: int
	LDX	4,U		variable gd
	LDX	6,X		optim: removeTfrDX
* optim: removeTfrDX
	JSR	,X
	LEAS	6,S
* Line errdiff.c:126: assignment: =
	LEAX	-17,U		member r of color_type, via variable screenPixel
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LDD	-55,U		variable i
	ADDD	#$01		1
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:127: assignment: =
	LEAX	-12,U		member g of color_type, via variable screenPixel
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LDD	-55,U		variable i
	ADDD	#$01		1
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	LEAX	5,X		member g of color_type
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:128: assignment: =
	LEAX	-7,U		member b of color_type, via variable screenPixel
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LDD	-55,U		variable i
	ADDD	#$01		1
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	LEAX	10,X		member b of color_type
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
L00190	EQU	*		else clause of if() started at errdiff.c:116
* Useless label L00192 removed
* Line errdiff.c:132: if
	LDD	-55,U		variable i
	CMPD	#$01
	LBLE	L00194		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00193 removed
* Line errdiff.c:132
* Line errdiff.c:133: assignment: =
* Line errdiff.c:133: function call: applyError()
	LEAX	F00195,PCR	real constant: 0.1875 (float)
	LEAS	-5,S		pass float by value
	LBSR	push5ByteStruct	argument 3 of applyError(): float
	LEAX	-53,U		address of array quantError
* optim: optimizePshsOps
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	-55,U		variable i
	ADDD	#$0140		320
	SUBD	,S++
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	LDB	#15		size of struct color_type
	LEAS	-15,S		pass struct color_type by value
	LBSR	pushSmallStruct	argument 1 of applyError(): struct color_type
	LEAX	-85,U		address of struct/union to be returned by applyError()
	PSHS	X		hidden argument
	LBSR	_applyError
	LEAS	24,S
	LEAX	-85,U		address of struct/union returned by applyError()
	LDD	#15		size of struct color_type
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-17,U		variable `screenPixel', declared at errdiff.c:101
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:134: function call through pointer
* Line errdiff.c:134: function call: findNearestColor()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of findNearestColor(): int
	LEAX	-17,U		variable `screenPixel', declared at errdiff.c:101
	LDB	#15		size of struct color_type
	LEAS	-15,S		pass struct color_type by value
	LBSR	pushSmallStruct	argument 1 of findNearestColor(): struct color_type
	LBSR	_findNearestColor
	LEAS	17,S
	PSHS	B,A		argument 3: int
	LDB	9,U		variable y
	ADDB	#$01		1
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2: unsigned char
	LDD	-55,U		variable i
	ADDD	#$FFFF		65535
	PSHS	B,A		argument 1: int
	LDX	4,U		variable gd
	LDX	6,X		optim: removeTfrDX
* optim: removeTfrDX
	JSR	,X
	LEAS	6,S
* Line errdiff.c:135: assignment: =
	LEAX	-17,U		member r of color_type, via variable screenPixel
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LDB	#$01		optim: removeAndOrMulAddSub
	PSHS	B,A
	LDD	-55,U		variable i
	ADDD	#$0140		320
	SUBD	,S++
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:136: assignment: =
	LEAX	-12,U		member g of color_type, via variable screenPixel
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LDB	#$01		optim: removeAndOrMulAddSub
	PSHS	B,A
	LDD	-55,U		variable i
	ADDD	#$0140		320
	SUBD	,S++
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	LEAX	5,X		member g of color_type
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:137: assignment: =
	LEAX	-7,U		member b of color_type, via variable screenPixel
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LDB	#$01		optim: removeAndOrMulAddSub
	PSHS	B,A
	LDD	-55,U		variable i
	ADDD	#$0140		320
	SUBD	,S++
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	LEAX	10,X		member b of color_type
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
L00194	EQU	*		else clause of if() started at errdiff.c:132
* Useless label L00196 removed
* Line errdiff.c:142: assignment: =
* Line errdiff.c:142: function call: applyError()
	LEAX	F00197,PCR	real constant: 0.3125 (float)
	LEAS	-5,S		pass float by value
	LBSR	push5ByteStruct	argument 3 of applyError(): float
	LEAX	-53,U		address of array quantError
	PSHS	X		argument 2 of applyError(): int[]
	LDD	-55,U		variable i
	ADDD	#$0140		320
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	LDB	#15		size of struct color_type
	LEAS	-15,S		pass struct color_type by value
	LBSR	pushSmallStruct	argument 1 of applyError(): struct color_type
	LEAX	-70,U		address of struct/union to be returned by applyError()
	PSHS	X		hidden argument
	LBSR	_applyError
	LEAS	24,S
	LEAX	-70,U		address of struct/union returned by applyError()
	LDD	#15		size of struct color_type
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-17,U		variable `screenPixel', declared at errdiff.c:101
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:143: function call through pointer
* Line errdiff.c:143: function call: findNearestColor()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of findNearestColor(): int
	LEAX	-17,U		variable `screenPixel', declared at errdiff.c:101
	LDB	#15		size of struct color_type
	LEAS	-15,S		pass struct color_type by value
	LBSR	pushSmallStruct	argument 1 of findNearestColor(): struct color_type
	LBSR	_findNearestColor
	LEAS	17,S
	PSHS	B,A		argument 3: int
	LDB	9,U		variable y
	ADDB	#$01		1
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2: unsigned char
	LDD	6,U		variable `x', declared at errdiff.c:97
	PSHS	B,A		argument 1: unsigned int
	LDX	4,U		variable gd
	LDX	6,X		optim: removeTfrDX
* optim: removeTfrDX
	JSR	,X
	LEAS	6,S
* Line errdiff.c:144: assignment: =
	LEAX	-17,U		member r of color_type, via variable screenPixel
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LDD	-55,U		variable i
	ADDD	#$0140		320
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:145: assignment: =
	LEAX	-12,U		member g of color_type, via variable screenPixel
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LDD	-55,U		variable i
	ADDD	#$0140		320
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	LEAX	5,X		member g of color_type
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:146: assignment: =
	LEAX	-7,U		member b of color_type, via variable screenPixel
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LDD	-55,U		variable i
	ADDD	#$0140		320
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	LEAX	10,X		member b of color_type
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:150: if
	LDD	-55,U		variable i
	ADDD	#$01		1
	CMPD	#320
	LBGE	L00199		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00198 removed
* Line errdiff.c:150
* Line errdiff.c:151: assignment: =
* Line errdiff.c:151: function call: applyError()
	LEAX	F00200,PCR	real constant: 0.0625 (float)
	LEAS	-5,S		pass float by value
	LBSR	push5ByteStruct	argument 3 of applyError(): float
	LEAX	-53,U		address of array quantError
* optim: optimizePshsOps
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	X,B,A		optim: optimizePshsOps
	LDD	-55,U		variable i
	ADDD	#$0140		320
	ADDD	,S++
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	LDB	#15		size of struct color_type
	LEAS	-15,S		pass struct color_type by value
	LBSR	pushSmallStruct	argument 1 of applyError(): struct color_type
	LEAX	-85,U		address of struct/union to be returned by applyError()
	PSHS	X		hidden argument
	LBSR	_applyError
	LEAS	24,S
	LEAX	-85,U		address of struct/union returned by applyError()
	LDD	#15		size of struct color_type
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-17,U		variable `screenPixel', declared at errdiff.c:101
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:152: function call through pointer
* Line errdiff.c:152: function call: findNearestColor()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of findNearestColor(): int
	LEAX	-17,U		variable `screenPixel', declared at errdiff.c:101
	LDB	#15		size of struct color_type
	LEAS	-15,S		pass struct color_type by value
	LBSR	pushSmallStruct	argument 1 of findNearestColor(): struct color_type
	LBSR	_findNearestColor
	LEAS	17,S
	PSHS	B,A		argument 3: int
	LDB	9,U		variable y
	ADDB	#$01		1
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2: unsigned char
	LDD	6,U		variable x
	ADDD	#$01		1
	PSHS	B,A		argument 1: unsigned int
	LDX	4,U		variable gd
	LDX	6,X		optim: removeTfrDX
* optim: removeTfrDX
	JSR	,X
	LEAS	6,S
* Line errdiff.c:153: assignment: =
	LEAX	-17,U		member r of color_type, via variable screenPixel
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LDB	#$01		optim: removeAndOrMulAddSub
	PSHS	B,A
	LDD	-55,U		variable i
	ADDD	#$0140		320
	ADDD	,S++
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:154: assignment: =
	LEAX	-12,U		member g of color_type, via variable screenPixel
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LDB	#$01		optim: removeAndOrMulAddSub
	PSHS	B,A
	LDD	-55,U		variable i
	ADDD	#$0140		320
	ADDD	,S++
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	LEAX	5,X		member g of color_type
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line errdiff.c:155: assignment: =
	LEAX	-7,U		member b of color_type, via variable screenPixel
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LDB	#$01		optim: removeAndOrMulAddSub
	PSHS	B,A
	LDD	-55,U		variable i
	ADDD	#$0140		320
	ADDD	,S++
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LDX	10,U		pointer co
	LEAX	D,X		add offset
	LEAX	10,X		member b of color_type
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
L00199	EQU	*		else clause of if() started at errdiff.c:150
* Useless label L00201 removed
* Useless label L00187 removed
* Line errdiff.c:103: for increment(s)
	LDD	-55,U
	ADDD	#1
	STD	-55,U
L00186	EQU	*
* Line errdiff.c:103: for condition
	LDD	-55,U		variable i
	CMPD	#$0140
	LBLT	L00185
* optim: branchToNextLocation
* Useless label L00188 removed
* Useless label L00132 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION errorDiffusiongDither(): defined at errdiff.c:97
funcend_errorDiffusiongDither	EQU *
funcsize_errorDiffusiongDither	EQU	funcend_errorDiffusiongDither-_errorDiffusiongDither


	ENDSECTION




	SECTION	initgl




*******************************************************************************

* Initialize global variables.


	ENDSECTION




	SECTION	rodata


string_literals_start	EQU	*
string_literals_end	EQU	*
real_constants_start	EQU	*


*******************************************************************************

* REAL CONSTANTS
F00155	EQU	*
	FCB	$93,$43,$50,$00,$00
F00158	EQU	*
	FCB	$88,$7F,$00,$00,$00
F00191	EQU	*
	FCB	$7F,$60,$00,$00,$00
F00195	EQU	*
	FCB	$7E,$40,$00,$00,$00
F00197	EQU	*
	FCB	$7F,$20,$00,$00,$00
F00200	EQU	*
	FCB	$7D,$00,$00,$00,$00
real_constants_end	EQU	*


*******************************************************************************

* READ-ONLY GLOBAL VARIABLES


	ENDSECTION




	SECTION	rwdata


* Statically-initialized global variables
_palette	EQU	*		palette: struct color_type[]
* Element 0 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$82,$00,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$82,$00,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$82,$00,$00,$00,$00
* Element 1 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$87,$14,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$82,$00,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$00,$00,$00,$00,$00
* Element 2 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$87,$14,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$87,$14,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$88,$2C,$00,$00,$00
* Element 3 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$87,$14,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$87,$14,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$87,$14,$00,$00,$00
* Element 4 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$88,$2C,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$87,$14,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$82,$00,$00,$00,$00
* Element 5 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$87,$14,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$88,$2C,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$82,$00,$00,$00,$00
* Element 6 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$88,$7D,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$87,$14,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$82,$00,$00,$00,$00
* Element 7 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$88,$2C,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$88,$2C,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$88,$2C,$00,$00,$00
* Element 8 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$82,$00,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$88,$2C,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$88,$7D,$00,$00,$00
* Element 9 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$88,$6B,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$88,$2C,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$87,$14,$00,$00,$00
* Element 10 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$87,$14,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$88,$2C,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$88,$2C,$00,$00,$00
* Element 11 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$87,$14,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$88,$7D,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$87,$14,$00,$00,$00
* Element 12 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$88,$7D,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$88,$2C,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$82,$00,$00,$00,$00
* Element 13 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$82,$00,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$88,$7D,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$88,$7D,$00,$00,$00
* Element 14 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$88,$2C,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$88,$2C,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$82,$00,$00,$00,$00
* Element 15 of array, of type struct color_type
* Element 0 of compound initializer: member 'r' of type float
	FCB	$88,$7D,$00,$00,$00
* Element 1 of compound initializer: member 'g' of type float
	FCB	$88,$7D,$00,$00,$00
* Element 2 of compound initializer: member 'b' of type float
	FCB	$88,$7D,$00,$00,$00
_FS_STANDARD	EQU	*		FS_STANDARD: float[]
* Element 0 of array, of type float
	FCB	$83,$00,$00,$00,$00
* Element 1 of array, of type float
	FCB	$81,$00,$00,$00,$00
* Element 2 of array, of type float
	FCB	$00,$00,$00,$00,$00
* Element 3 of array, of type float
	FCB	$7F,$60,$00,$00,$00
* Element 4 of array, of type float
	FCB	$81,$80,$00,$00,$00
* Element 5 of array, of type float
	FCB	$81,$00,$00,$00,$00
* Element 6 of array, of type float
	FCB	$7E,$40,$00,$00,$00
* Element 7 of array, of type float
	FCB	$00,$00,$00,$00,$00
* Element 8 of array, of type float
	FCB	$81,$00,$00,$00,$00
* Element 9 of array, of type float
	FCB	$7F,$20,$00,$00,$00
* Element 10 of array, of type float
	FCB	$81,$00,$00,$00,$00
* Element 11 of array, of type float
	FCB	$81,$00,$00,$00,$00
* Element 12 of array, of type float
	FCB	$7D,$00,$00,$00,$00
* Element 13 of array, of type float
	FCB	$00,$00,$00,$00,$00
* Statically-initialized local static variables


	ENDSECTION




	SECTION	bss


bss_start	EQU	*
* Uninitialized global variables
* Uninitialized local static variables
bss_end	EQU	*


	ENDSECTION




*******************************************************************************

* Importing 15 utility routine(s).
MUL16	IMPORT
MUL168	IMPORT
_memcpy	IMPORT
addSingleSingle	IMPORT
cmpSingleSignedInt	IMPORT
cmpSingleSingle	IMPORT
copyMem	IMPORT
initSignedWordFromSingle	IMPORT
initSingleFromSignedWord	IMPORT
initSingleFromSingle	IMPORT
mulIntSingle	IMPORT
mulSingleSingle	IMPORT
push5ByteStruct	IMPORT
pushSmallStruct	IMPORT
subSingleSingle	IMPORT


*******************************************************************************

	END
