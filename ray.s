* 6809 assembly program generated by cmoc 0.1.85


	SECTION	code


_isCoCo3	IMPORT
_textScreenWidth	IMPORT
_textScreenHeight	IMPORT
_twoLines	EXPORT
_pixelCounter	EXPORT
_startAtLine	EXPORT
___va_arg	IMPORT
_abs	IMPORT
_adddww	IMPORT
_atanf	IMPORT
_atoff	IMPORT
_atoi	IMPORT
_atol	IMPORT
_atoui	IMPORT
_atoul	IMPORT
_attr	IMPORT
_bsearch	IMPORT
_cls	IMPORT
_cmp	IMPORT
_cmpdww	IMPORT
_coldStart	IMPORT
_cosf	IMPORT
_delay	IMPORT
_divdwb	IMPORT
_divdww	IMPORT
_divmod16	IMPORT
_divmod8	IMPORT
_do_lighting	IMPORT
_dwtoa	IMPORT
_enableCMOCFloatSupport	IMPORT
_errorDiffusiongDither	IMPORT
_exit	IMPORT
_expf	IMPORT
_fabsf	IMPORT
_findNearestColor	IMPORT
_floorf	IMPORT
_ftoa	IMPORT
_getTextMode	IMPORT
_hscreen	IMPORT
_hset	IMPORT
_initCoCoSupport	IMPORT
_inkey	IMPORT
_intersect	IMPORT
_isKeyPressed	IMPORT
_isalnum	IMPORT
_isalpha	IMPORT
_isdigit	IMPORT
_isspace	IMPORT
_itoa10	IMPORT
_labs	IMPORT
_locate	IMPORT
_logf	IMPORT
_ltoa10	IMPORT
_memchr	IMPORT
_memcmp	IMPORT
_memcpy	IMPORT
_memichr	IMPORT
_memicmp	IMPORT
_memmove	IMPORT
_memset	IMPORT
_memset16	IMPORT
_mulwb	IMPORT
_mulww	IMPORT
_palette	IMPORT
_paletteRGB	IMPORT
_pcls	IMPORT
_plane_intersect	IMPORT
_pln_lighting	IMPORT
_pmode	IMPORT
_printf	IMPORT
_putchar	IMPORT
_putstr	IMPORT
_qsort	IMPORT
_rand	IMPORT
_readDECBFile	IMPORT
_readJoystickButtons	IMPORT
_readJoystickPositions	IMPORT
_readline	IMPORT
_readword	IMPORT
_resetPalette	IMPORT
_rgb	IMPORT
_roundf	IMPORT
_sbrk	IMPORT
_sbrkmax	IMPORT
_screen	IMPORT
_setBorderColor	IMPORT
_setCaseFlag	IMPORT
_setConsoleOutHook	IMPORT
_setHighSpeed	IMPORT
_setOutputDevice	IMPORT
_setPmodeGraphicsAddressEx	IMPORT
_setSAMRegisters	IMPORT
_set_null_ptr_handler	IMPORT
_set_stack_overflow_handler	IMPORT
_showGraphicsAddress	IMPORT
_showLowResTextAddress	IMPORT
_showPmode4	IMPORT
_sinf	IMPORT
_sleep	IMPORT
_sound	IMPORT
_sprintf	IMPORT
_sqrt16	IMPORT
_sqrt32	IMPORT
_sqrtf	IMPORT
_srand	IMPORT
_strcat	IMPORT
_strchr	IMPORT
_strcmp	IMPORT
_strcpy	IMPORT
_stricmp	IMPORT
_strlen	IMPORT
_strlwr	IMPORT
_strncmp	IMPORT
_strncpy	IMPORT
_strstr	IMPORT
_strtof	IMPORT
_strtol	IMPORT
_strtoul	IMPORT
_strupr	IMPORT
_subdww	IMPORT
_tanf	IMPORT
_tolower	IMPORT
_toupper	IMPORT
_truncf	IMPORT
_ultoa10	IMPORT
_utoa10	IMPORT
_vec_diff	IMPORT
_vec_dot	IMPORT
_vec_len	IMPORT
_vec_scale	IMPORT
_vec_sum	IMPORT
_vprintf	IMPORT
_vsprintf	IMPORT
_waitkey	IMPORT
_width	IMPORT
_zerodw	IMPORT
_ray	EXPORT


*******************************************************************************

* FUNCTION ray(): defined at ray.c:85
_ray	EQU	*
* Calling convention: Default
	PSHS	U
	LEAU	,S
	LEAS	-350,S
* Formal parameter(s):
*      4,U:    2 bytes: gd: struct GraphicsDriver *
* Local non-static variable(s):
*   -350,U:   15 bytes: RGB2: struct color_type
*   -335,U:   15 bytes: $V00146: struct color_type
*   -330,U:    5 bytes: $V00143: float
*   -325,U:    5 bytes: $V00144: float
*   -320,U:    5 bytes: $V00147: float
*   -315,U:    5 bytes: $V00148: float
*   -310,U:    5 bytes: $V00149: float
*   -305,U:   15 bytes: rgb: struct color_type
*   -290,U:    5 bytes: t: float
*   -285,U:   22 bytes: plnx: struct intersect
*   -263,U:    2 bytes: i: int
*   -261,U:    2 bytes: closest_i: int
*   -259,U:   15 bytes: co: struct color_type
*   -244,U:    5 bytes: $V00134: float
*   -239,U:    5 bytes: $V00135: float
*   -234,U:    5 bytes: $V00136: float
*   -229,U:    5 bytes: $V00137: float
*   -224,U:    5 bytes: $V00138: float
*   -219,U:    5 bytes: $V00139: float
*   -214,U:    5 bytes: $V00140: float
*   -209,U:   22 bytes: $V00141: struct intersect
*   -187,U:    5 bytes: $V00150: float
*   -182,U:    5 bytes: $V00151: float
*   -177,U:    5 bytes: $V00152: float
*   -172,U:   30 bytes: ray: struct ray_type
*   -142,U:    2 bytes: wid: int
*   -140,U:    2 bytes: hgt: int
*   -138,U:    5 bytes: ratio: float
*   -133,U:   70 bytes: sph: struct sphere_type[]
*    -63,U:    2 bytes: num: int
*    -61,U:   20 bytes: pln: struct plane_type
*    -41,U:   30 bytes: light: struct light_type
*    -11,U:    2 bytes: x: int
*     -9,U:    2 bytes: y: int
*     -7,U:    2 bytes: lasty: int
*     -5,U:    5 bytes: $V00133: float
* Line ray.c:101: init of variable wid
	LDD	#$0140		320
	STD	-142,U		variable wid
* Line ray.c:102: init of variable hgt
	CLRA
	LDB	#$C8		200
	STD	-140,U		variable hgt
* Line ray.c:103: init of variable ratio
* Push right operand of div.
	LEAX	F00153,PCR	real constant: 400 (float)
	PSHS	X
* Push left operand of div.
	LEAX	F00154,PCR	real constant: 480 (float)
	PSHS	X
	LEAX	-5,U		temporary destination, type float
	LBSR	divSingleSingle	preserves X
	LEAS	4,S
	TFR	X,D		address of source number in D
	LEAX	-138,U		address of variable to init: ratio
	LBSR	initSingleFromSingle
* Line ray.c:110: init of variable num
	CLRA
	LDB	#$02		2
	STD	-63,U		variable num
* Line ray.c:114: assignment: =
	LEAX	F00155,PCR	real constant: 0.5 (float)
	LDB	#5		optim: removeAndOrMulAddSub
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-133,U		index 0 in array sph[]
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:115: assignment: =
	LEAX	F00156,PCR	real constant: 0.8 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65408,U		index 0 in array sph[]
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:116: assignment: =
	LEAX	F00157,PCR	real constant: 4 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65413,U		index 0 in array sph[]
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:117: assignment: =
	LEAX	F00155,PCR	real constant: 0.5 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65418,U		index 0 in array sph[]
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:118: assignment: =
	LEAX	F00158,PCR	real constant: 0.3 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65423,U		index 0 in array sph[]
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:119: assignment: =
	LEAX	F00159,PCR	real constant: 0 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65423,U		index 0 in array sph[]
* optim: coalesceConsecutiveLeax
	LEAX	5,X		member g of color_type
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:120: assignment: =
	LEAX	F00159,PCR	real constant: 0 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65423,U		index 0 in array sph[]
* optim: coalesceConsecutiveLeax
	LEAX	10,X		member b of color_type
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:123: assignment: =
	LEAX	F00160,PCR	real constant: -0.5 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-98,U		index 1 in array sph[]
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:124: assignment: =
	LEAX	F00161,PCR	real constant: 0.15 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65443,U		index 1 in array sph[]
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:125: assignment: =
	LEAX	F00162,PCR	real constant: 4.2 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65448,U		index 1 in array sph[]
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:126: assignment: =
	LEAX	F00163,PCR	real constant: 0.6 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65453,U		index 1 in array sph[]
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:127: assignment: =
	LEAX	F00159,PCR	real constant: 0 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65458,U		index 1 in array sph[]
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:128: assignment: =
	LEAX	F00158,PCR	real constant: 0.3 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65458,U		index 1 in array sph[]
* optim: coalesceConsecutiveLeax
	LEAX	5,X		member g of color_type
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:129: assignment: =
	LEAX	F00159,PCR	real constant: 0 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65458,U		index 1 in array sph[]
* optim: coalesceConsecutiveLeax
	LEAX	10,X		member b of color_type
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:133: assignment: =
	LEAX	F00159,PCR	real constant: 0 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-61,U		member norm of plane_type, via variable pln
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:134: assignment: =
	LEAX	F00164,PCR	real constant: 1 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65480,U		member norm of plane_type, via variable pln
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:135: assignment: =
	LEAX	F00159,PCR	real constant: 0 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65485,U		member norm of plane_type, via variable pln
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:136: assignment: =
	LEAX	F00165,PCR	real constant: -1 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-46,U		member D of plane_type, via variable pln
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:141: assignment: =
	LEAX	F00166,PCR	real constant: 5 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-41,U		member origin of light_type, via variable light
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:142: assignment: =
	LEAX	F00167,PCR	real constant: 10 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65500,U		member origin of light_type, via variable light
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:143: assignment: =
	LEAX	F00168,PCR	real constant: -2 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65505,U		member origin of light_type, via variable light
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:144: assignment: =
	LEAX	F00164,PCR	real constant: 1 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-26,U		member amount of light_type, via variable light
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:145: assignment: =
	LEAX	F00164,PCR	real constant: 1 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65515,U		member amount of light_type, via variable light
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:146: assignment: =
	LEAX	F00164,PCR	real constant: 1 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65520,U		member amount of light_type, via variable light
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:155: init of variable x
	CLRA
	CLRB
	STD	-11,U		variable x
* Line ray.c:155: init of variable y
* optim: stripExtraClrA_B
* optim: stripExtraClrA_B
	STD	-9,U		variable y
* Line ray.c:155: init of variable lasty
* optim: stripExtraClrA_B
	LDB	#$01		1
	STD	-7,U		variable lasty
* Line ray.c:156: for init
* Line ray.c:156: assignment: =
* optim: stripExtraClrA_B
	CLRB
	STD	-9,U
	LBRA	L00170		jump to for condition
L00169	EQU	*
* Line ray.c:156: for body
* Line ray.c:157: for init
* Line ray.c:157: assignment: =
	CLRA
	CLRB
	STD	-11,U
	LBRA	L00174		jump to for condition
L00173	EQU	*
* Line ray.c:157: for body
* Line ray.c:160: assignment: =
	CLRA
	CLRB
* optim: stripUselessPushPull
	LEAX	-172,U		member or of ray_type, via variable ray
* optim: stripUselessPushPull
	LBSR	initSingleFromSignedWord
* Line ray.c:161: assignment: =
	CLRA
	CLRB
* optim: stripUselessPushPull
	LEAX	65369,U		member or of ray_type, via variable ray
* optim: coalesceConsecutiveLeax
* optim: stripUselessPushPull
	LBSR	initSingleFromSignedWord
* Line ray.c:162: assignment: =
	CLRA
	CLRB
* optim: stripUselessPushPull
	LEAX	65374,U		member or of ray_type, via variable ray
* optim: coalesceConsecutiveLeax
* optim: stripUselessPushPull
	LBSR	initSingleFromSignedWord
* Line ray.c:166: assignment: =
* Push right operand of add.
* Push right operand of div.
	LDD	-142,U		variable `wid', declared at ray.c:101
	LEAX	-234,U		destination of cast
	LBSR	initSingleFromSignedWord
	PSHS	X
* Push left operand of div.
	LDD	-11,U		variable `x', declared at ray.c:155
	PSHS	B,A
	LEAX	-239,U		temporary destination, type float
	LBSR	divIntSingle	preserves X
	LEAS	4,S
	PSHS	X
* Push left operand of add.
	LEAX	F00177,PCR	real constant: -0.67 (float)
	PSHS	X
	LEAX	-244,U		temporary destination, type float
	LBSR	addSingleSingle	preserves X
	LEAS	4,S
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-157,U		member dir of ray_type, via variable ray
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:167: assignment: =
* Push right operand of sub.
* Push right operand of div.
* Push right operand of div.
	LEAX	-138,U		variable `ratio', declared at ray.c:103
	PSHS	X
* Push left operand of div.
	LDD	-142,U		variable `wid', declared at ray.c:101
	LEAX	-214,U		destination of cast
	LBSR	initSingleFromSignedWord
	PSHS	X
	LEAX	-219,U		temporary destination, type float
	LBSR	divSingleSingle	preserves X
	LEAS	4,S
	PSHS	X
* Push left operand of div.
	LDD	-9,U		variable `y', declared at ray.c:155
	PSHS	B,A
	LEAX	-224,U		temporary destination, type float
	LBSR	divIntSingle	preserves X
	LEAS	4,S
	PSHS	X
* Push left operand of sub.
	LEAX	F00155,PCR	real constant: 0.5 (float)
	PSHS	X
	LEAX	-229,U		temporary destination, type float
	LBSR	subSingleSingle	preserves X
	LEAS	4,S
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65384,U		member dir of ray_type, via variable ray
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:168: assignment: =
	LEAX	F00164,PCR	real constant: 1 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	65389,U		member dir of ray_type, via variable ray
* optim: coalesceConsecutiveLeax
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:172: assignment: =
	LEAX	F00178,PCR	real constant: 0.1 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-305,U		member r of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:173: assignment: =
	LEAX	F00158,PCR	real constant: 0.3 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-300,U		member g of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:174: assignment: =
	LEAX	F00155,PCR	real constant: 0.5 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-295,U		member b of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:177: init of variable t
	LEAX	F00179,PCR	real constant: 20000 (float)
	TFR	X,D		address of source number in D
	LEAX	-290,U		address of variable to init: t
	LBSR	initSingleFromSingle
* Line ray.c:183: init of variable plnx
* Line ray.c:183: function call: plane_intersect()
	LEAX	-61,U		variable `pln', declared at ray.c:132
	PSHS	X		argument 2 of plane_intersect(): struct plane_type *
	LEAY	-172,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-209,U		address of struct/union to be returned by plane_intersect()
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_plane_intersect
	LEAS	6,S
	LEAX	-209,U		address of struct/union returned by plane_intersect()
	PSHS	X		source struct
	LDD	#22		size of struct intersect
	LEAX	-285,U		destination struct: plnx
	LBSR	copyMem		initialize struct
	LEAS	2,S
* Line ray.c:187: if
	LDD	-265,U		member flag of intersect, via variable plnx
	CMPD	#1
	LBNE	L00181		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00180 removed
* Line ray.c:187
* Line ray.c:188: if
	CLRA
	LDB	#$01		decimal 1 signed
	PSHS	B,A
* Line ray.c:188: function call: floorf()
	LEAX	65261,U		member p of intersect, via variable plnx
* optim: coalesceConsecutiveLeax
	LEAS	-5,S		pass float by value
	LBSR	push5ByteStruct	argument 1 of floorf(): float
	LEAX	-325,U		address of struct/union to be returned by floorf()
	PSHS	X		hidden argument
	LBSR	_floorf
	LEAS	7,S
	LEAX	-325,U		address of struct/union returned by floorf()
	TFR	X,D		cast to `int': address of source number in D
	LEAS	-2,S		result of cast
	LEAX	,S
	LBSR	initSignedWordFromSingle
	PULS	A,B		result of cast
	PSHS	B,A
* Line ray.c:188: function call: floorf()
	LEAX	65256,U		member p of intersect, via variable plnx
* optim: coalesceConsecutiveLeax
	LEAS	-5,S		pass float by value
	LBSR	push5ByteStruct	argument 1 of floorf(): float
	LEAX	-330,U		address of struct/union to be returned by floorf()
	PSHS	X		hidden argument
	LBSR	_floorf
	LEAS	7,S
	LEAX	-330,U		address of struct/union returned by floorf()
	TFR	X,D		cast to `int': address of source number in D
	LEAS	-2,S		result of cast
	LEAX	,S
	LBSR	initSignedWordFromSingle
	PULS	A,B		result of cast
	PSHS	B,A
* Line ray.c:188: function call: floorf()
	LEAX	-285,U		member p of intersect, via variable plnx
	LEAS	-5,S		pass float by value
	LBSR	push5ByteStruct	argument 1 of floorf(): float
	LEAX	-335,U		address of struct/union to be returned by floorf()
	PSHS	X		hidden argument
	LBSR	_floorf
	LEAS	7,S
	LEAX	-335,U		address of struct/union returned by floorf()
	TFR	X,D		cast to `int': address of source number in D
	LEAS	-2,S		result of cast
	LEAX	,S
	LBSR	initSignedWordFromSingle
	PULS	A,B		result of cast
	ADDD	,S++
	ADDD	,S++
	ANDA	,S+
	ANDB	,S+
	ADDD	#0
	BEQ	L00183		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00182 removed
* Line ray.c:188
* Line ray.c:189: assignment: =
	LEAX	F00159,PCR	real constant: 0 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-305,U		member r of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:190: assignment: =
	LEAX	F00159,PCR	real constant: 0 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-300,U		member g of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:191: assignment: =
	LEAX	F00159,PCR	real constant: 0 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-295,U		member b of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
	BRA	L00184		jump over else clause
L00183	EQU	*		else clause of if() started at ray.c:188
* Line ray.c:192
* Line ray.c:193: assignment: =
	LEAX	F00164,PCR	real constant: 1 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-305,U		member r of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:194: assignment: =
	LEAX	F00164,PCR	real constant: 1 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-300,U		member g of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:195: assignment: =
	LEAX	F00164,PCR	real constant: 1 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-295,U		member b of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
L00184	EQU	*		end of if() started at ray.c:188
* Line ray.c:197: init of variable RGB1
* Line ray.c:197: function call: pln_lighting()
	LEAY	-285,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-172,U		variable `ray', declared at ray.c:98
	PSHS	Y,X		optim: optimizePshsOps
	LEAY	-41,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-320,U		address of struct/union to be returned by pln_lighting()
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_pln_lighting
	LEAS	8,S
	LEAX	-320,U		address of struct/union returned by pln_lighting()
	PSHS	X		source struct
	LDD	#15		size of struct color_type
	LEAX	-350,U		destination struct: RGB1
	LBSR	copyMem		initialize struct
	LEAS	2,S
* Line ray.c:198: assignment: *=
* Push right operand of mul.
	LEAX	-350,U		member r of color_type, via variable RGB1
	PSHS	X
* Push left operand of mul.
	LEAX	-305,U		member r of color_type, via variable rgb
	PSHS	X
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
* Line ray.c:199: assignment: *=
* Push right operand of mul.
	LEAX	-345,U		member g of color_type, via variable RGB1
	PSHS	X
* Push left operand of mul.
	LEAX	-300,U		member g of color_type, via variable rgb
	PSHS	X
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
* Line ray.c:200: assignment: *=
* Push right operand of mul.
	LEAX	-340,U		member b of color_type, via variable RGB1
	PSHS	X
* Push left operand of mul.
	LEAX	-295,U		member b of color_type, via variable rgb
	PSHS	X
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
L00181	EQU	*		else clause of if() started at ray.c:187
* Useless label L00185 removed
* Line ray.c:205: init of variable closest_i
	LDD	#$FFFF		65535
	STD	-261,U		variable closest_i
* Line ray.c:206: for init
* Line ray.c:206: assignment: =
	CLRA
	CLRB
	STD	-263,U
	LBRA	L00187		jump to for condition
L00186	EQU	*
* Line ray.c:206: for body
* Line ray.c:209: if
* Line ray.c:209: function call: intersect()
	LDX	-9,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-11,U		variable `x', declared at ray.c:155
	PSHS	X,B,A		optim: optimizePshsOps
	LEAX	-290,U		variable `t', declared at ray.c:177
	PSHS	X		argument 3 of intersect(): float *
	LDX	-263,U		variable i
	LDB	#35		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	-133,U		address of array sph
	LEAY	D,X		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-172,U		variable `ray', declared at ray.c:98
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_intersect
	LEAS	10,S
	CMPD	#1
	BNE	L00191		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00190 removed
* Line ray.c:209
* Line ray.c:210: assignment: =
* optim: stripConsecutiveLoadsToSameReg
	LDD	-263,U
	STD	-261,U
L00191	EQU	*		else clause of if() started at ray.c:209
* Useless label L00192 removed
* Line ray.c:214: if
	LDD	-261,U		variable closest_i
	ADDD	#0
	LBLT	L00194		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00193 removed
* Line ray.c:214
* Line ray.c:215: init of variable RGB2
* Line ray.c:215: function call: do_lighting()
	LEAX	-290,U		variable `t', declared at ray.c:177
	PSHS	X		argument 4 of do_lighting(): float *
	LDX	-261,U		variable closest_i
	LDB	#35		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	-133,U		address of array sph
	LEAY	D,X		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-172,U		variable `ray', declared at ray.c:98
	PSHS	Y,X		optim: optimizePshsOps
	LEAY	-41,U		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LEAX	-335,U		address of struct/union to be returned by do_lighting()
	PSHS	Y,X		optim: optimizePshsOps
	LBSR	_do_lighting
	LEAS	10,S
	LEAX	-335,U		address of struct/union returned by do_lighting()
	PSHS	X		source struct
	LDD	#15		size of struct color_type
	LEAX	-350,U		destination struct: RGB2
	LBSR	copyMem		initialize struct
	LEAS	2,S
* Line ray.c:216: assignment: =
* Push right operand of add.
	LEAX	-350,U		member r of color_type, via variable RGB2
	PSHS	X
* Push left operand of add.
	LDX	-261,U		variable closest_i
	LDB	#35		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	-133,U		address of array sph
	LEAX	D,X		add offset
	LEAX	20,X		member sclr of sphere_type
	PSHS	X
	LEAX	-320,U		temporary destination, type float
	LBSR	addSingleSingle	preserves X
	LEAS	4,S
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-305,U		member r of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:217: assignment: =
* Push right operand of add.
	LEAX	-345,U		member g of color_type, via variable RGB2
	PSHS	X
* Push left operand of add.
	LDX	-261,U		variable closest_i
	LDB	#35		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	-133,U		address of array sph
	LEAX	D,X		add offset
	LEAX	25,X		member sclr of sphere_type
* optim: coalesceConsecutiveLeax
	PSHS	X
	LEAX	-315,U		temporary destination, type float
	LBSR	addSingleSingle	preserves X
	LEAS	4,S
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-300,U		member g of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:218: assignment: =
* Push right operand of add.
	LEAX	-340,U		member b of color_type, via variable RGB2
	PSHS	X
* Push left operand of add.
	LDX	-261,U		variable closest_i
	LDB	#35		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	-133,U		address of array sph
	LEAX	D,X		add offset
	LEAX	30,X		member sclr of sphere_type
* optim: coalesceConsecutiveLeax
	PSHS	X
	LEAX	-310,U		temporary destination, type float
	LBSR	addSingleSingle	preserves X
	LEAS	4,S
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-295,U		member b of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
L00194	EQU	*		else clause of if() started at ray.c:214
* Useless label L00195 removed
* Useless label L00188 removed
* Line ray.c:206: for increment(s)
	LDD	-263,U
	ADDD	#1
	STD	-263,U
L00187	EQU	*
* Line ray.c:206: for condition
	LDD	-263,U		variable i
	CMPD	#$02
	LBLT	L00186
* optim: branchToNextLocation
* Useless label L00189 removed
* Line ray.c:226: if
* push right operand of comparison
	LEAX	F00164,PCR	real constant: 1 (float)
	PSHS	X
* push left operand of comparison
	LEAX	-305,U		member r of color_type, via variable rgb
	PSHS	X
	LBSR	cmpSingleSingle	sets N, Z, V, C; preserves X
	LEAS	4,S
	BLE	L00197		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00196 removed
* Line ray.c:226
* Line ray.c:226: assignment: =
	LEAX	F00164,PCR	real constant: 1 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-305,U		member r of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
L00197	EQU	*		else clause of if() started at ray.c:226
* Useless label L00198 removed
* Line ray.c:227: if
* push right operand of comparison
	LEAX	F00164,PCR	real constant: 1 (float)
	PSHS	X
* push left operand of comparison
	LEAX	-300,U		member g of color_type, via variable rgb
	PSHS	X
	LBSR	cmpSingleSingle	sets N, Z, V, C; preserves X
	LEAS	4,S
	BLE	L00200		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00199 removed
* Line ray.c:227
* Line ray.c:227: assignment: =
	LEAX	F00164,PCR	real constant: 1 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-300,U		member g of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
L00200	EQU	*		else clause of if() started at ray.c:227
* Useless label L00201 removed
* Line ray.c:228: if
* push right operand of comparison
	LEAX	F00164,PCR	real constant: 1 (float)
	PSHS	X
* push left operand of comparison
	LEAX	-295,U		member b of color_type, via variable rgb
	PSHS	X
	LBSR	cmpSingleSingle	sets N, Z, V, C; preserves X
	LEAS	4,S
	BLE	L00203		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00202 removed
* Line ray.c:228
* Line ray.c:228: assignment: =
	LEAX	F00164,PCR	real constant: 1 (float)
	LDD	#5		size of struct _Float
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LEAX	-295,U		member b of color_type, via variable rgb
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
L00203	EQU	*		else clause of if() started at ray.c:228
* Useless label L00204 removed
* Line ray.c:246: init of variable co
* Push right operand of mul.
	LEAX	F00205,PCR	real constant: 255 (float)
	PSHS	X
* Push left operand of mul.
	LEAX	-305,U		member r of color_type, via variable rgb
	PSHS	X
	LEAX	-187,U		temporary destination, type float
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
	TFR	X,D		address of source number
	LEAX	-259,U		offset in variable co
	LBSR	copySingle	preserves X
* Push right operand of mul.
	LEAX	F00205,PCR	real constant: 255 (float)
	PSHS	X
* Push left operand of mul.
	LEAX	-300,U		member g of color_type, via variable rgb
	PSHS	X
	LEAX	-182,U		temporary destination, type float
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
	TFR	X,D		address of source number
	LEAX	-254,U		offset in variable co
	LBSR	copySingle	preserves X
* Push right operand of mul.
	LEAX	F00205,PCR	real constant: 255 (float)
	PSHS	X
* Push left operand of mul.
	LEAX	-295,U		member b of color_type, via variable rgb
	PSHS	X
	LEAX	-177,U		temporary destination, type float
	LBSR	mulSingleSingle	preserves X
	LEAS	4,S
	TFR	X,D		address of source number
	LEAX	-249,U		offset in variable co
	LBSR	copySingle	preserves X
* Line ray.c:250: function call through pointer
	LDY	#$06		optim: transformPshsXPshsX
* optim: optimizePshsOps
	LDX	-9,U		optim: transformPshsDPshsD
* optim: optimizePshsOps
	LDD	-11,U		variable `x', declared at ray.c:155
	PSHS	Y,X,B,A		optim: optimizePshsOps
	LDX	4,U		variable gd
	LDX	6,X		optim: removeTfrDX
* optim: removeTfrDX
	JSR	,X
	LEAS	6,S
* Line ray.c:252: assignment: =
	LEAX	-259,U		variable `co', declared at ray.c:246
	LDD	#15		size of struct color_type
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LDD	_pixelCounter+0,PCR	variable `pixelCounter', declared at ray.c:252
	ADDD	#1
	STD	_pixelCounter+0,PCR
	SUBD	#1		post increment yields initial value
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LEAX	_twoLines+0,PCR	address of array twoLines
	LEAX	D,X		add offset
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Line ray.c:260: if
	LDD	_pixelCounter+0,PCR	variable pixelCounter
	CMPD	#$0280
	LBLO	L00207		 (optim: condBranchOverUncondBranch)
* optim: condBranchOverUncondBranch
* Useless label L00206 removed
* Line ray.c:260
* Line ray.c:262: function call: errorDiffusiongDither()
	LEAX	_twoLines+0,PCR	address of array twoLines
	PSHS	X		argument 4 of errorDiffusiongDither(): struct color_type[]
	LDD	-9,U		variable y
	ADDD	#$FFFF		65535
	PSHS	B,A		argument 3 of errorDiffusiongDither(): int
	CLRA
	CLRB
	PSHS	B,A		argument 2 of errorDiffusiongDither(): int
	LDD	4,U		variable `gd', declared at ray.c:85
	PSHS	B,A		argument 1 of errorDiffusiongDither(): struct GraphicsDriver *
	LBSR	_errorDiffusiongDither
	LEAS	8,S
* Line ray.c:263: assignment: =
	LDD	#$0140		decimal 320 signed
	STD	_pixelCounter+0,PCR
* Line ray.c:265: for init
* Line ray.c:265: init of variable i
	LDD	#$0140		320
	STD	-307,U		variable i
	BRA	L00209		jump to for condition
L00208	EQU	*
* Line ray.c:265: for body
* Line ray.c:266: assignment: =
	LDX	-307,U		variable i
	LDB	#15		size of array element (optim: arrayIndexMul)
	LBSR	MUL168		get offset in bytes in D
	LEAX	_twoLines+0,PCR	address of array twoLines
	LEAX	D,X		add offset
	LDD	#15		size of struct color_type
	PSHS	B,A		push size to _memcpy
	PSHS	X		source struct
	LDD	-307,U		variable i
	ADDD	#$FEC0		65216
	LDX	#15		size of array element
	LBSR	MUL16		get offset in bytes in D
	LEAX	_twoLines+0,PCR	address of array twoLines
	LEAX	D,X		add offset
	PSHS	X
	LBSR	_memcpy		copy struct (preserves X)
	LEAS	6,S
* Useless label L00210 removed
* Line ray.c:265: for increment(s)
	LDD	-307,U
	ADDD	#1
	STD	-307,U
L00209	EQU	*
* Line ray.c:265: for condition
	LDD	-307,U		variable i
	CMPD	#$0280
	BLT	L00208
* optim: branchToNextLocation
* Useless label L00211 removed
L00207	EQU	*		else clause of if() started at ray.c:260
* Useless label L00212 removed
* Useless label L00175 removed
* Line ray.c:157: for increment(s)
	LDD	-11,U
	ADDD	#1
	STD	-11,U
L00174	EQU	*
* Line ray.c:157: for condition
	LDD	-11,U		variable x
	CMPD	-142,U		variable wid
	LBLT	L00173
* optim: branchToNextLocation
* Useless label L00176 removed
* Useless label L00171 removed
* Line ray.c:156: for increment(s)
	LDD	-9,U
	ADDD	#1
	STD	-9,U
L00170	EQU	*
* Line ray.c:156: for condition
	LDD	-9,U		variable y
	CMPD	-140,U		variable hgt
	LBLT	L00169
* optim: branchToNextLocation
* Useless label L00172 removed
* Useless label L00132 removed
	LEAS	,U
	PULS	U,PC
* END FUNCTION ray(): defined at ray.c:85
funcend_ray	EQU *
funcsize_ray	EQU	funcend_ray-_ray


	ENDSECTION




	SECTION	initgl




*******************************************************************************

* Initialize global variables.


	ENDSECTION




	SECTION	rodata


string_literals_start	EQU	*
string_literals_end	EQU	*
real_constants_start	EQU	*


*******************************************************************************

* REAL CONSTANTS
F00153	EQU	*
	FCB	$89,$48,$00,$00,$00
F00154	EQU	*
	FCB	$89,$70,$00,$00,$00
F00155	EQU	*
	FCB	$80,$00,$00,$00,$00
F00156	EQU	*
	FCB	$80,$4C,$CC,$CC,$CC
F00157	EQU	*
	FCB	$83,$00,$00,$00,$00
F00158	EQU	*
	FCB	$7F,$19,$99,$99,$99
F00159	EQU	*
	FCB	$00,$00,$00,$00,$00
F00160	EQU	*
	FCB	$80,$80,$00,$00,$00
F00161	EQU	*
	FCB	$7E,$19,$99,$99,$99
F00162	EQU	*
	FCB	$83,$06,$66,$66,$66
F00163	EQU	*
	FCB	$80,$19,$99,$99,$99
F00164	EQU	*
	FCB	$81,$00,$00,$00,$00
F00165	EQU	*
	FCB	$81,$80,$00,$00,$00
F00166	EQU	*
	FCB	$83,$20,$00,$00,$00
F00167	EQU	*
	FCB	$84,$20,$00,$00,$00
F00168	EQU	*
	FCB	$82,$80,$00,$00,$00
F00177	EQU	*
	FCB	$80,$AB,$85,$1E,$B8
F00178	EQU	*
	FCB	$7D,$4C,$CC,$CC,$CC
F00179	EQU	*
	FCB	$8F,$1C,$40,$00,$00
F00205	EQU	*
	FCB	$88,$7F,$00,$00,$00
real_constants_end	EQU	*


*******************************************************************************

* READ-ONLY GLOBAL VARIABLES


	ENDSECTION




	SECTION	rwdata


* Statically-initialized global variables
_pixelCounter	EQU	*		pixelCounter: unsigned int
	FDB	$00		decimal 0
_startAtLine	EQU	*		startAtLine: unsigned char
	FCB	$00		decimal 0
* Statically-initialized local static variables


	ENDSECTION




	SECTION	bss


bss_start	EQU	*
* Uninitialized global variables
_twoLines	EQU	*
	RMB	9600		twoLines
* Uninitialized local static variables
bss_end	EQU	*


	ENDSECTION




*******************************************************************************

* Importing 21 utility routine(s).
MUL16	IMPORT
MUL168	IMPORT
_do_lighting	IMPORT
_errorDiffusiongDither	IMPORT
_floorf	IMPORT
_intersect	IMPORT
_memcpy	IMPORT
_plane_intersect	IMPORT
_pln_lighting	IMPORT
addSingleSingle	IMPORT
cmpSingleSingle	IMPORT
copyMem	IMPORT
copySingle	IMPORT
divIntSingle	IMPORT
divSingleSingle	IMPORT
initSignedWordFromSingle	IMPORT
initSingleFromSignedWord	IMPORT
initSingleFromSingle	IMPORT
mulSingleSingle	IMPORT
push5ByteStruct	IMPORT
subSingleSingle	IMPORT


*******************************************************************************

	END
